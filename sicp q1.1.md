問題1.2
gosh> (/
        (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
        (* 3 (- 6 2) (- 2 7))
        )
-37/150

問題1.3
gosh> (define (summary a b c)
        (cond
          ((and (> a c) (> b c)) (+ (* a a) (* b b)))
          ((and (> a b) (> c b)) (+ (* a a) (* c c)))
          (else (+ (* b b) (* c c)))))
summary

問題1.4
bが0より大きければa+bを返し、それ以外の場合はa-bを返す。
つまりaにbの絶対値を加算して返す手続きである。

問題1.5
定義testの振る舞いとして、x=0の場合は帰結式が評価され返される。
解釈系が正規順序の場合は、式を完全に展開するときに代替式(p)を展開しようとして無限に評価を繰り返すことになる。
解釈系が作用的順序の場合は、x=0の場合、代替式を評価せずに式の評価が完了する。

問題1.6
場合分けを記述する特殊形式ではない場合（cond, ifを使わない場合）である
新しいnew-ifでは引数のpredicate, then-clause, else-clauseを評価したあと、
condの述語、帰結部に展開するのでelse-clauseに展開されるsqrt-iterが再帰的に無限に評価されることになる。
と思われる。

問題1.7
非常に大きい数の場合、
例えば
(sqrt-iter 1.0 8000000000000)
から結果が帰ってこなくなる。
(sqrt-iter 1.0 7999999999999)
はかえってくる。
improveを繰り返しやってみると
gosh> (improve 4.0000000000005e12 8000000000000)
2.00000000000125e12
gosh> (improve 2.00000000000125e12 8000000000000)
1.000000000002625e12
gosh> (improve 1.000000000002625e12 8000000000000)
5.000000000053125e11
gosh> (improve 5.000000000053125e11 8000000000000)
2.5000000001065625e11
gosh> (improve 2.5000000001065625e11 8000000000000)
1.2500000002132812e11
gosh> (improve 1.2500000002132812e11 8000000000000)
6.250000004266406e10
gosh> (improve 6.250000004266406e10 8000000000000)
3.125000008533203e10
gosh> (improve 3.125000008533203e10 8000000000000)
1.5625000170666016e10
gosh> (improve 1.5625000170666016e10 8000000000000)
7.812500341333005e9
gosh> (improve 7.812500341333005e9 8000000000000)
3.90625068266648e9
gosh> (improve 3.90625068266648e9 8000000000000)
1.953126365333061e9
gosh> (improve 1.953126365333061e9 8000000000000)
976565230.6650988
gosh> (improve 976565230.6650988 8000000000000)
488286711.3210962
gosh> (improve 488286711.3210962 8000000000000)
244151547.56892335
gosh> (improve 244151547.56892335 8000000000000)
122092157.05149327
gosh> (improve 122092157.05149327 8000000000000)
61078840.66294365
gosh> (improve 61078840.66294365 8000000000000)
30604909.45923824
gosh> (improve 30604909.45923824 8000000000000)
15433152.714703096
gosh> (improve 15433152.714703096 8000000000000)
7975758.656259873
gosh> (improve 7975758.656259873 8000000000000)
4489399.017026309
gosh> (improve 4489399.017026309 8000000000000)
3135687.363419739
gosh> (improve 3135687.363419739 8000000000000)
2843481.057636803
gosh> (improve 2843481.057636803 8000000000000)
2828466.973947026
gosh> (improve 2828466.973947026 8000000000000)
2828427.1250269003
gosh> (improve 2828427.1250269003 8000000000000)
2828427.1247461904
gosh> (improve 2828427.1247461904 8000000000000)
2828427.1247461904
gosh> (improve 2828427.1247461904 8000000000000)
2828427.1247461904

2828427.1247461904よりも精度が高まらなくなるようだ。

gosh> (good-enough? 2828427.1247461904 8000000000000)
#f
はfalseとなり、無限ループになってしまう。

gosh> (square 2828427.1247461904)
8.000000000000002e12
推定値の平方がこのような値となるが、8000000000000との差が0.001よりも大きい。
何度やってもこの結果となるため無限ループになる模様。

精度についてはimproveの演算を、下記の式で見てみる。
```
gosh> (/ 8000000000000 2828427.1247461904)
2828427.12474619
gosh> (/ (+ 2828427.12474619 2828427.1247461904) 2)
2828427.1247461904
```
good-enough?がfalseであるにも関わらずimproveによって値が変わらなくなっている。
おそらく浮動小数点演算の誤差によるものだろう。

7999999999999の場合を見てみるとたまたま精度が枯渇する前にテスト条件を満たす値が見つかるから無限ループにならないですんでいる。
それ以下の値でも精度が足りずに無限ループになってしまう場合はあった。


非常に小さい数（小数点以下）の場合、十分な探索をする前に(abs (- (square guess) x))の評価結果が0.001未満となってしまう。
以下の結果を見ればわかるだろう（本来は0.002が解である）
gosh> (sqrt-iter 1.0 0.000004)
0.03129261341049664

もう1つの戦略：
ある繰り返しから次のguessへの変化が予測値に比べて、非常に小さくなったときに止める。

今のテストは、[被開平数]と[予測値の2乗]の差の絶対値が一定の許容量より小さくなるまでテストをする。
これを、予測値自身と予測値の前後差を比較し、一定量より小さくなるまでテストをする設計に変更する。
つまり、大雑把な推測をしている間は変化が大きいが、徐々に変化が小さくなっていくことを利用する。
例えば、変化が0.1%未満であるか？という検証をするならば、

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (good-enough? guess x)
  (< (abs (- 1 (/ guess (improve guess x)))) 0.000000001))
この変化率は0.5以上2以下であるはずなので、1との差分から絶対値をとり、0.1%未満という検証にする。

gosh> (sqrt-iter 1.0 0.000004)
0.0020000000000000235
gosh> (sqrt-iter 1.0 2)
1.4142135623746899
gosh> (sqrt-iter 1.0 8000000000000)
2828427.1250269003

このような結果になった。精度が若干甘いが…多少はよくなった。

ネットで解答例を見て改良したやつ

(define (good-enough? guess x)
  (< (/ (abs (- guess (improve guess x))) guess) 0.000000001))
あんま変わんないというか、次の予測値がどうか？という判定になってるから１段甘いのが変わってない。
sqrt-iterに前の予測値渡すようにしないとだ


問題1.8

よりよい近似の導出

(define (improve-cubert guess x)
  (/
    (+
      (/ x (square guess))
      (* 2 guess)
    )
    3)
  )

テストは問題1.7で改善した手法に則る
(define (good-enough-cubert? guess x)
  (< (/ (abs (- guess (improve-cubert guess x))) guess) 0.000000001))

イテレーションテスト
(define (crt-iter guess x)
  (if (good-enough-cubert? guess x)
    guess
    (crt-iter (improve-cubert guess x)
      x)))
